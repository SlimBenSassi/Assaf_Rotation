%% Exercise: Comparing Second-beat ERPs: rhythm vs interval, short vs long
%% 1. LOAD PREPROCESSED DATA

%file reading code from ERP.m script

clear; close all; clc
disp('--- Extracting a couple trials ---');

% --- Configuration ---
DEFAULT_PATH = 'C:\Users\ssassi\Desktop\Assaf_Rotation\Data'; % Default folder where your processed data is saved
%example christina data: \\wks3\pr_breska\el-Christina\Backup Copy Christina\PF_Poster\Data\EEG\
% christina eeg trigger list "\\wks3\pr_breska\el-Christina\SxA\SxA_Data\EEGTriggerList.docx"

% --- 1. Use UIGETFILE for Interactive Selection (GUI Dialog) ---
[filename, filepath] = uigetfile({'*.mat','MATLAB Data File (*.mat)' ;'*.*', 'All files (*.*)'},...
                                    'Select Clean Preprocessed SDATA File', DEFAULT_PATH);

if isequal(filename, 0)
    disp('No file selected. Aborting script.');
    return; 
end

full_file_path = fullfile(filepath, filename);

% --- 2. Load the Data ---
try
    % Load only the SDATA variable from the selected .mat file
    load(full_file_path, 'SDATA');
    disp(['Loaded clean data from: ' filename]);
catch ME
    disp(['ERROR: Failed to load SDATA structure from ' filename]);
    disp(['MATLAB Error: ' ME.message]);
    error('Aborting due to critical data loading failure.');
end




%% --- Global Variables ---

Fs = SDATA.info.sampling_rate;
data_matrix = SDATA.data; % [Time x Channels]
channel_labels = SDATA.info.channel_labels;
n_channels = size(data_matrix, 2);
events = SDATA.events.triggerChannel; % Raw Status Channel vector
alpha_freq_range = [8, 12]; % Alpha band for filtering (Hz)

% --- Time Variables --- %
pred_window_s = 0.100; % 200ms pre-stimulus prediction window (used for non-time resolved average across window)
PRE_EVENT_SEC = 0.9; %taking all time since warning signal 
POST_EVENT_SEC = 0.3;
total_epoch_samples = round((PRE_EVENT_SEC + POST_EVENT_SEC) * Fs);
erp_time_vec = (0:total_epoch_samples - 1) / Fs - PRE_EVENT_SEC;
pre_samples = round(PRE_EVENT_SEC * Fs);
pred_start_sample = pre_samples + round(-pred_window_s * Fs); % e.g., sample 410 at 1024Hz
pred_end_sample = pre_samples;

% ---  Event Codes --- %
target_codes = [012, 013, 014, 015, 016, 022, 023, 024, 025, 026, 212, 213, 214, 215, 216, 222, 223, 224, 225, 226]; % (01X means contrast X+1) Targets: Rhythm Target Contrast 4,5,6,7 Right, same but Left (contrasts around threshold) 
%target_codes = [014, 015, 016, 024, 025, 026, 214, 215, 216, 224, 225, 226];
%targer_codes = [014, 015, 016, 024, 025, 026];
report_unseen_code = [231, 241]; % Subjective report code for 'Did Not See' for rhythm 231, for interval 241
report_seen_codes = [232, 233, 234, 242, 243, 244]; % Subjective report
%codes for 'Saw' (Hit) for rhythm 232, for interval 242
%report_seen_codes = [232, 233, 234];

max_target_trials_per_condition = 1000; 

% --- Channels --- %
single_channel_idx = 48; % Cz=48, Oz=29
ROI.Central = {[11, 12, 13, 46, 47, 48 ,49], "Central Cluster"};
ROI.Occipital = {[25, 26, 27, 29, 30, 62, 63, 64], "Occipital Cluster"};
ROI.All = {[1:n_channels], "All Channels"};
ROI.Single = {[single_channel_idx], num2str(single_channel_idx)}; %put electrode of interest idx in here
current_ROI_cell = ROI.Occipital;
currentROI = current_ROI_cell{1};
currentROI_name = current_ROI_cell{2};

%% 0. Rereferencing in case data is in mastoids reference to amplify occipital signals

SDATA = reref_to_nose(SDATA);


%% 0. Rereferencing in case data is in mastoids reference to amplify occipital signals

% --- CONDITIONAL RE-REFERENCE FIX (M-to-N) ---
if isequal(SDATA.metadata.reference, [69, 70])
    % 1. Calculate the current reference signal (Average of M1 and M2 - Channels 69 and 70)
    current_ref_signal = mean(SDATA.data(:, [69, 70]), 2);
    
    % 2. Calculate the difference between the Nose electrode (new reference) and the old reference
    nose_to_mastoid_diff = SDATA.data(:, 71) - current_ref_signal;
    
    % 3. Apply the re-reference: Subtract the difference from ALL channels.
    % This effectively changes the reference point for all data to the Nose electrode (Channel 71).
    SDATA.data = SDATA.data - nose_to_mastoid_diff;
    
    % 4. Update the metadata log
    SDATA.metadata.reference = [71];
    disp('Reference changed from Mastoids to Nose.');
else
    disp(['Data reference (' SDATA.metadata.reference ') retained.']);
end
% ---------------------------------------------
%% 1.1 Finding trials of interest

% --- 1. Extract Latencies and Codes from the Status Channel ---
status_vector = events;
trigger_indices = find(status_vector ~= 0); 
trigger_codes = status_vector(trigger_indices);

% --- 2. Link Targets to Subjective Outcomes  ---
% Initialize final lists
final_target_latencies = [];
final_target_codes = [];
y_subjective_outcome = []; % 0 = Unseen (Miss), 1 = Seen (Hit)

search_window = round(10 * Fs); % Search up to 10s after target for response

for i = 1:length(trigger_codes)
    current_code = trigger_codes(i);
    
    if ismember(current_code, target_codes)
        % Found a target event (014, 024, etc.)
        target_latency = trigger_indices(i);
        
        % Search for the next subjective report event
        found_report = false;
        
        % Search the next few indices (up to end of response window)
        for j = i + 1 : min(i + 4, length(trigger_codes)) % i+4 is because subj response is the fourth event after a target showing
            report_code = trigger_codes(j);
            
            if ismember(report_code, [report_unseen_code, report_seen_codes])
                % Found a report event (231, 232, etc.)
                
                % Check if the report occurred within a reasonable time window (e.g., 500ms)
                if trigger_indices(j) - target_latency < search_window
                    
                    final_target_latencies = [final_target_latencies; target_latency];
                    final_target_codes = [final_target_codes; current_code];
                    
                    % Determine binary outcome: 1 if Saw (232/233/234), 0 if Unseen (231)
                    if ismember(report_code, report_unseen_code)
                        y_subjective_outcome = [y_subjective_outcome; 0]; % Unseen/Miss
                    else
                        y_subjective_outcome = [y_subjective_outcome; 1]; % Seen/Hit
                    end
                    found_report = true;
                    break; % Stop searching for reports once one is found
                end
            end
        end
        % Skip trials where no report was found (e.g., participant timed out)
    end
end


% Calculate total number of successful target-response pairings
total_pairings = length(final_target_codes);

% Count occurrences of each target code that made it into the final list
unique_targets = unique(final_target_codes);

disp('--- Target-Response Linking Summary ---');
disp(['Total successfully linked trials (Targets + Responses): ' num2str(total_pairings)]);

% Loop through the specific codes of interest to display individual counts
for code = target_codes
    count = sum(final_target_codes == code);
    disp(['  > Code ' num2str(code) ' found: ' num2str(count) ' trials.']); %TODO: make this show 0s too
end
disp('---------------------------------------');

% Optional: 1.2 Taking less trials to run stuff quickly (controlled by
% max_target_trials_per_condition

% --- 1. Initialize Storage for Sampled Indices ---
sampled_indices_cell = cell(1, length(target_codes));
disp('--- Optional: Taking less trials to run stuff quickly ---');y_su

% --- 2. Loop Through Each Target Code ---
for i = 1:length(target_codes)
    code = target_codes(i);
    
    % Find all indices for the current target code (e.g., all 014 trials)
    idx_full = find(final_target_codes == code);
    
    % Select the first N trials (up to target_trials_per_condition)
    n_available = length(idx_full);
    n_sample = min(n_available, max_target_trials_per_condition);
    
    % Store the sampled indices in the cell array
    sampled_indices_cell{i} = idx_full(1:n_sample);
    
    disp(['  > Code ' num2str(code) ': Sampled ' num2str(n_sample) ' of ' num2str(n_available) ' available trials.']);
end

% --- 3. Consolidate Indices and Data ---
% Vertically stack all sampled indices into one master list
final_sample_indices = vertcat(sampled_indices_cell{:});

%% Selecting trials of interest

[epoch_latencies, epoch_codes, y_subjective_outcome, n_trials] = select_single_trials(SDATA, target_codes, report_unseen_code, report_seen_codes);

%% Rejecting trials of interests that contain artifacts

[epoch_latencies, epoch_codes, y_subjective_outcome, n_trials] = reject_artifact_trials(SDATA, epoch_latencies, epoch_codes, y_subjective_outcome, total_epoch_samples, pre_samples);

%% SKIP for now (functionized above)

% Final Trial Data is sliced using the master list
epoch_latencies = final_target_latencies(final_sample_indices);
epoch_codes = final_target_codes(final_sample_indices);
y_subjective_outcome = y_subjective_outcome(final_sample_indices);

n_trials = length(final_sample_indices);

disp(['Selected ' num2str(n_trials) ' total trials for analysis.']);



%% 2.1 ALPHA POWER EXTRACTION (Lab's TFhilbert Method)

% --- Configuration for Padding ---
LOWEST_FREQ = alpha_freq_range(1); % Get the lowest frequency (8 Hz)
PAD_CYCLES = 2; % Standard practice: Pad by 2 cycles of the lowest frequency
PAD_SAMPLES = round(PAD_CYCLES * Fs / LOWEST_FREQ); % Calculate samples needed for padding
disp(['Padding ' num2str(PAD_SAMPLES) ' samples (' num2str(PAD_SAMPLES/Fs, 2) 's) per side for edge artifact control.']);

total_epoch_samples_padded = total_epoch_samples + 2 * PAD_SAMPLES; % New, larger size
% ... (rest of the initial config) ...

% --- 1. Epoching the Clean Data (Output: [Time x Channels x Trials]) ---
pre_samples_padded = pre_samples + PAD_SAMPLES; % Shift the effective 0ms point
all_epochs_alpha = zeros(total_epoch_samples_padded, n_channels, n_trials); % Initialize larger array

for trial_idx = 1:n_trials
    center_idx = epoch_latencies(trial_idx); 
    
    % *** NEW START/END CALCULATION ***
    start_idx = center_idx - pre_samples_padded; % Start earlier
    end_idx = start_idx + total_epoch_samples_padded - 1; % End later
    
    % Safety check: ensure indices are within bounds
    if start_idx >= 1 && end_idx <= size(data_matrix, 1)
        % Extract the segment (the right side is the padded time window)
        all_epochs_alpha(:, :, trial_idx) = data_matrix(start_idx:end_idx, :);
    else
        % --- If the trial is too close to the file edge, use mirroring/zero padding here.
        % For simplicity in this script, we will skip padding for boundary trials.
        % This is where complex logic for mirroring data would go.
    end
end
disp('Alpha-band epoching complete and padded.');

% --- Configuration ---
total_epoch_samples = round((PRE_EVENT_SEC + POST_EVENT_SEC) * Fs); %add stuff then chop it
erp_time_vec = (0:total_epoch_samples - 1) / Fs - PRE_EVENT_SEC;

%% SKIP FOR NOW original 2.1



% % --- 1. Epoching the Clean Data (Output: [Time x Channels x Trials]) ---
% pre_samples = round(PRE_EVENT_SEC * Fs);
% all_epochs_alpha = zeros(total_epoch_samples, n_channels, n_trials);
% 
% for trial_idx = 1:n_trials
%     center_idx = epoch_latencies(trial_idx); 
%     start_idx = center_idx - pre_samples;
%     end_idx = start_idx + total_epoch_samples - 1;
% 
%     if start_idx >= 1 && end_idx <= size(data_matrix, 1)
%         all_epochs_alpha(:, :, trial_idx) = data_matrix(start_idx:end_idx, :);
%     end
% end
% disp('Alpha-band epoching complete.');

%% SKIP (functionalized above)

%2.bis.0: TRIAL ARTIFACT REJECTION (Sample Masking to Trial Rejection)

disp('Applying trial-level artifact rejection...');

% --- 1. Prepare Artifact Mask ---
% Get the continuous artifact mask (N_time_points x 1 vector)
artifact_mask_cont = SDATA.metadata.artifacts; 

% 2. Initialize a logical vector to mark bad trials
is_good_trial = true(n_trials, 1); 



% 3. The Rejection Loop: Check every trial segment
for trial_idx = 1:n_trials
    
    center_idx = epoch_latencies(trial_idx); 
    start_idx = center_idx - pre_samples;
    end_idx = start_idx + total_epoch_samples - 1;
    
    % Check the continuous artifact mask in the time window of the current trial
    trial_artifact_segment = artifact_mask_cont(start_idx:end_idx);
    
    % If ANY sample in this segment is marked '1' (artifact), the whole trial is BAD.
    if any(trial_artifact_segment) 
        is_good_trial(trial_idx) = false;
        disp(center_idx)

    end
end

% --- 4. Apply Rejection to Data and Labels ---
disp(['Rejected ' num2str(sum(~is_good_trial)) ' trials due to artifacts.']);


% Filter all trial-dependent variables to keep only good trials:
all_epochs_alpha = all_epochs_alpha(:, :, is_good_trial);
epoch_latencies = epoch_latencies(is_good_trial);
epoch_codes = epoch_codes(is_good_trial);
y_subjective_outcome = y_subjective_outcome(is_good_trial);
n_trials = sum(is_good_trial); % Update the total trial count

disp(['Final N for analysis: ' num2str(n_trials)]);

%%

% --- 2. TFhilbert Call (CRITICAL DIMENSIONAL SWAP) ---
% The function processes trials sequentially. We must process each channel across all trials.
% We reshape the 3D data into [Trials*Time x Channels] and then process it, 
% or process trial-by-trial, which is cleaner.

% The function expects [Trials/Channels x Time]. We will call it in a simple loop 
% over the channels, processing time across trials.

% We analyze only the single Alpha band (8-12 Hz) for this single-trial test.
frequencies_to_analyze = [alpha_freq_range(1): alpha_freq_range(2)]; % Use 10 Hz as the center frequency
filt_width_octaves = 0.2; 
causalFilt = false; % Use zero-phase filtering


% Initialize the final power envelope matrix [Time x Channels x Trials]
alpha_power_envelope = zeros(total_epoch_samples_padded, length(frequencies_to_analyze), n_channels, n_trials);

for ch = 1:n_channels
    % Extract all time courses for the current channel across all trials: [Time x 1 x Trials]
    channel_data = squeeze(all_epochs_alpha(:, ch, :)); 
    
    % Call the lab's function: Input must be [Trials x Time]
    % Transpose the channel_data [Time x Trials] to [Trials x Time]
    [hil_amp, ~] = TFhilbert(frequencies_to_analyze, filt_width_octaves, channel_data', Fs, causalFilt);
    
    % TFhilbert output is [Freqs x Time x Trials]. 
    % We store the power (amp^2) back into the final matrix:
    alpha_power_envelope(:, :, ch, :) = permute(hil_amp, [2 1 3]); %hil_amp.^2 for power, hil_amp for amplitude
end

disp('TFhilbert processing complete. Power envelope calculated.');

% --- TRIMMING STEP (MUST OCCUR AFTER TFhilbert) ---
disp('Trimming edge padding...');

% Define the samples to keep (from sample PAD_SAMPLES + 1 up to the end minus PAD_SAMPLES)
start_trim_idx = PAD_SAMPLES + 1;
end_trim_idx = total_epoch_samples_padded - PAD_SAMPLES;

% Slice the power envelope to remove the padding in the Time dimension (Dimension 1)
alpha_power_envelope = alpha_power_envelope(start_trim_idx:end_trim_idx, :, :, :);

% Verify the size is back to normal (total_epoch_samples)
disp(['Final time points after trimming: ' num2str(size(alpha_power_envelope, 1))]);

% %% 2.2 BASELINE NORMALIZATION (Power Dynamics)
% 
% disp('Calculating baseline-normalized Alpha power (dB)...');
% 
% % --- Configuration: Baseline Window ---
% baseline_end_sec = -0.900; 
% baseline_start_sec = -0.500;
% Fs = SDATA.info.sampling_rate;
% 
% baseline_start_sample = round(PRE_EVENT_SEC * Fs) + round(baseline_start_sec * Fs); 
% baseline_end_sample = round(PRE_EVENT_SEC * Fs) + round(baseline_end_sec * Fs);
% 
% % 1. Calculate the mean baseline power 
% mean_baseline_power = mean(mean(alpha_power_envelope(baseline_start_sample:baseline_end_sample, :, :, :), 1), 4);
% 
% % --- CRITICAL FIX 1: Shield the BASELINE (Denominator) ---
% % Replace any zero/negative baseline values with a small, positive constant (eps)
% mean_baseline_power(mean_baseline_power <= eps) = eps; 
% 
% % --- CRITICAL FIX 2: Shield the POWER (Numerator) ---
% % Replace any zero/negative power values with a small, positive constant
% alpha_power_envelope(alpha_power_envelope <= eps) = eps; 
% 
% % 2. Apply Log-Ratio Normalization (Decibel Conversion)
% % dB Power = 10 * log10(Power / BaselinePower)
% alpha_power_normalized_dB = 10 * log10(bsxfun(@rdivide, alpha_power_envelope, mean_baseline_power));
% 
% disp('Baseline normalization (dB) complete. Ready for T-Map analysis.');


%% 2.3: PLOT SINGLE-TRIAL & COMPARISON AVERAGES

time_vec_full_epoch = (0:total_epoch_samples - 1) / Fs - PRE_EVENT_SEC;
time_vec_sec = time_vec_full_epoch(1:pred_end_sample);

alpha_power_3D_avg_freq = squeeze(mean(alpha_power_envelope, 2)); % Result: [Time x Channels x Trials]

% 2. Slice to get the specific Channel (Cz proxy)
% Result: [Time x Trials]
power_traces = squeeze(mean(alpha_power_3D_avg_freq(:, currentROI, :),2));

% --- Find Indices for Grouping ---
idx_seen = (y_subjective_outcome == 1);
idx_unseen = (y_subjective_outcome == 0);

% --- Calculate Group Averages (Crucial Step) ---
% Average across the Trial dimension (Dimension 2 of power_traces)
Avg_Seen_Power = mean(power_traces(:, idx_seen), 2);
Avg_Unseen_Power = mean(power_traces(:, idx_unseen), 2);

figure('Units', 'normalized', 'Position', [0.1 0.1 0.6 0.8]); % Opens a tall, single figure

% --- SUBPLOT 1 (Top): ALL SINGLE TRIALS + GRAND AVERAGE ---
subplot(2, 1, 1);
plot(time_vec_full_epoch, power_traces, 'Color', [0.7 0.7 0.7], 'LineWidth', 0.5, 'HandleVisibility', 'off'); % All trials (gray)
hold on;
plot(time_vec_full_epoch, mean(power_traces, 2), 'k', 'LineWidth', 3.0, 'DisplayName', 'Grand Average'); % Grand Average (thick black)
line([0 0], ylim, 'Color', 'r', 'LineStyle', '--','DisplayName', 'Target Onset' );
xlim([-PRE_EVENT_SEC, POST_EVENT_SEC]);
title(['Individual Trial Alpha Amplitude Traces (All Selected Trials)- Ch: ' num2str(currentROI_name)], 'FontSize', 12);
ylabel('Alpha Amplitude (\muV)');
legend('show', 'Location', 'NorthWest');
hold off;


% --- SUBPLOT 2 (Bottom): SEEN vs. UNSEEN COMPARISON ---
subplot(2, 1, 2);
plot(time_vec_full_epoch, Avg_Seen_Power, 'b', 'LineWidth', 3, 'DisplayName', 'SEEN Trials');
hold on;
plot(time_vec_full_epoch, Avg_Unseen_Power, 'r', 'LineWidth', 3, 'DisplayName', 'UNSEEN Trials');
line([0 0], ylim, 'Color', 'k', 'LineStyle', '--', 'DisplayName', 'Target Onset');
%line(xlim, [0 0], 'Color', [0.5 0.5 0.5], 'LineStyle', ':');
xlim([-PRE_EVENT_SEC, POST_EVENT_SEC]);
title(['Average Alpha Amplitude: Seen vs. Unseen Comparison - Ch: ' num2str(currentROI_name)] , 'FontSize', 12);
xlabel('Time relative to stimulus (s)');
ylabel('Alpha Amplitude (\muV)');
legend('show', 'Location', 'NorthEast');
hold off;


%% 3. FEATURE EXTRACTION AND HYPOTHESIS TESTING

% --- 1. Define the Prediction Window ---
pred_start_sample = pre_samples + round(-pred_window_s * Fs); % e.g., sample 820 for last 100ms at 1024Hz
pred_end_sample = pre_samples; % sample 512 (0ms)


% --- 3. Extract the Single-Trial Predictor (X) ---
% Average the Alpha power across the time window and the Pz channel for each trial.
% Result is [N_trials x 1] vector of mean Alpha power in the final 100ms.
%alpha_power_predictor = squeeze(mean(mean(mean(alpha_power_envelope(pred_start_sample:pred_end_sample, :, cz_channel_idx, :), 1), 2), 4));

% 1. Slice the window: [Time x Freqs x ROI x Trials]
sliced_power = alpha_power_envelope(pred_start_sample:pred_end_sample, :, currentROI, :);

% 2. Average across Time (Dim 1) and Frequencies (Dim 2) and channels (Dim
% 3)
mean_power_across_tf = squeeze(mean(mean(mean(sliced_power, 1), 2),3));
% The result of this average is now [Trials x 1] (because the first two dimensions collapsed)

% 3. Final assignment: Ensure it's a column vector [N_trials x 1]
alpha_power_predictor = reshape(mean_power_across_tf, n_trials, 1);

% --- 4. Hypothesis Testing (T-Test: Seen vs. Unseen) ---

% Split the alpha power predictor into two groups based on the subjective outcome (0 or 1)
alpha_seen_power = alpha_power_predictor(y_subjective_outcome == 1);
alpha_missed_power = alpha_power_predictor(y_subjective_outcome == 0);

disp('--- Running T-Test (Seen vs. Unseen) ---');
if length(alpha_seen_power) > 1 && length(alpha_missed_power) > 1
    
    [h, p, ci, stats] = ttest2(alpha_seen_power, alpha_missed_power, "Tail","Left"); %make sure about tail left
    
    disp(['T-Test Result:']);
    disp(['   Mean Power (Seen): ' num2str(mean(alpha_seen_power), 3)]);
    disp(['   Mean Power (Missed): ' num2str(mean(alpha_missed_power), 3)]);
    disp(['   T-stat = ' num2str(stats.tstat, 3) ', P-value = ' num2str(p, 4)]);
    
    % --- Plotting the Prediction ---
    figure;
    scatter(alpha_power_predictor, y_subjective_outcome, 50, 'filled');
    title('Single-Trial Alpha Power Predicting Subjective Outcome (0=Miss, 1=Seen)');
    xlabel(['Alpha Power (Avg ' num2str(pred_window_s*1000) 'ms pre-stim)']);
    %set(gca, 'XDir', 'reverse'); % Negative Upward\
    ylabel('Subjective Outcome');
    ylim([-0.1 1.1]);
    
else
    disp('Warning: Not enough trials in one group to run T-test.');
end


%% 4.1 TIME-RESOLVED FEATURE EXTRACTION AND HYPOTHESIS TESTING

% --- 1. Configuration ---
time_points = 1:total_epoch_samples; 

% --- 2. Define the Pre-Stimulus Time Window ---
% We will analyze the entire pre-stimulus period (-500ms to 0ms)
pred_start_time_idx = time_points(pred_start_sample);
pred_end_time_idx = time_points(pred_end_sample);
time_window_samples = pred_end_sample - pred_start_sample + 1;
pred_start_sample_idx = 1; 
pred_end_sample_idx = pre_samples; 

% --- 3. Initialize Output Matrices ---
% This will store the T-statistic and P-value for EVERY time point.
t_map_vector = zeros(time_window_samples, 1);
p_map_vector = zeros(time_window_samples, 1);
time_vec_pred = erp_time_vec(pred_start_sample:pred_end_sample);

disp(['Running time-resolved T-test across ' num2str(time_window_samples) ' time points...']);
tic

% --- 4. THE TIME-RESOLVED LOOP ---
for t_idx = 1:pred_end_sample
    
    % --- A. Extract Predictor for the current time point ---
    % Squeeze removes single dimensions. We take only the current time index (t_idx).
    % Result is a [N_trials x 1] vector of Alpha Power at this specific millisecond.
    %alpha_power_at_t = squeeze(alpha_power_envelope(pred_start_sample + t_idx - 1, cz_channel_idx, :));
    % Indexing: (Time_Index, ALL Freqs, Channel_Index, All_Trials)
    alpha_power_at_pixel_4D = squeeze(alpha_power_envelope(pred_start_sample_idx + t_idx - 1, :, currentROI, :)); 
    
    % FIX: Average the power across the Frequency dimension (Dimension 1 of the squeezed output)
    alpha_power_at_t = mean(mean(alpha_power_at_pixel_4D, 1),2);

    % Take log of power (is this standard?)
    %alpha_power_at_t = log10(alpha_power_at_t);

    % Output is now a 1xN_Trials vector of average Alpha power for this time point.
    % --- B. Split into Groups ---
    alpha_seen_power = alpha_power_at_t(y_subjective_outcome == 1);
    alpha_missed_power = alpha_power_at_t(y_subjective_outcome == 0);
    
    % --- C. Run T-Test ---
    if length(alpha_seen_power) > 1 && length(alpha_missed_power) > 1
        % ttest2 returns the p-value first, then the stats structure
        [h, p_val, ~, stats] = ttest2(alpha_seen_power, alpha_missed_power, "Tail", "Left");
        
        t_map_vector(t_idx) = stats.tstat;
        p_map_vector(t_idx) = p_val;
    else
        t_map_vector(t_idx) = NaN; % Assign NaN if not enough trials
    end
end
toc
disp('Time-resolved T-map computation finished.');


%% 4.2 PLOT TIME-RESOLVED T-MAP FOR POWER VALUES

figure;

% --- 1. Plot the T-statistic over time ---
plot(time_vec_sec, t_map_vector, 'b', 'LineWidth', 2);
hold on;

% --- 2. Add Significance Threshold (Alpha = 0.05) ---
% We calculate the threshold based on the T-distribution degrees of freedom (N_trials - 2)
df = n_trials - 2;
if df > 0
% T-value for p < 0.05, one-tailed (lower tail check)
    t_critical_neg = tinv(0.05, df); 
    
    % Only plot the critical negative line (or both if you want the boundary)
    line(xlim, [t_critical_neg t_critical_neg], 'Color', 'r', 'LineStyle', ':');
end

% --- 4. Plotting Significance Markers ---
% Find indices where P-value is significant (p < 0.05)
significant_indices = (p_map_vector < 0.05);

% Extract the time points and T-values ONLY at significant locations
significant_t_values = t_map_vector(significant_indices);
significant_time_points = time_vec_sec(significant_indices);

% Plot black circles (markers) at significant locations
%scatter(significant_time_points, significant_t_values, 50, 'k', 'filled');
% 50 is marker size, 'k' is color (black), 'filled' makes it solid.

sig_starts = find(diff([0; significant_indices; 0]) == 1);
sig_ends = find(diff([0; significant_indices; 0]) == -1) - 1;

% 2. Create the shading rectangles
if ~isempty(sig_starts)
    % Set the axes limits for the shading reference
    y_limits = ylim; 
    
    for k = 1:length(sig_starts)
        % Get the time index for the start and end of the significant block
        start_sample = sig_starts(k);
        end_sample = sig_ends(k);
        
        % Get the time in seconds for the shading
        t_start = time_vec_sec(start_sample);
        t_end = time_vec_sec(end_sample);
        
        % Use the PATCH function to draw a light yellow rectangle
        % Coordinates: [X_start, X_end, X_end, X_start] and [Y_bottom, Y_bottom, Y_top, Y_top]
        patch([t_start t_end t_end t_start], [y_limits(1) y_limits(1) y_limits(2) y_limits(2)], 'y', ...
              'FaceAlpha', 0.2, ... % Light transparency (0.2)
              'EdgeColor', 'none');
    end
end

% --- 3. Aesthetics ---
line([0 0], ylim, 'Color', 'k', 'LineStyle', '--'); % Vertical line at stimulus onset
line(xlim, [0 0], 'Color', [0.5 0.5 0.5], 'LineStyle', '-'); % Horizontal line at T=0
title(['Time-Resolved T-Map (Alpha Power: Seen vs. Unseen) - Ch: ' num2str(currentROI_name)]);
xlabel('Time relative to stimulus (s)');
ylabel('T-Statistic (Predictive Strength)');
legend()
grid on;
hold off;

%% 4.3 PLOT BASELINE-NORMALIZED AVERAGE POWER (DYNAMICS)

% --- Configuration ---
Fs = SDATA.info.sampling_rate;
time_vec_full = (0:size(alpha_power_envelope, 1) - 1) / Fs - PRE_EVENT_SEC;

% 1. Slice the normalized data for the chosen channel
norm_power_3D = squeeze(mean(alpha_power_normalized_dB(:, :, currentROI, :),3)); % [Time x Freqs x Trials]

% 2. Average across trials and select the main Alpha frequency (e.g., the third freq bin)
avg_norm_power_seen = mean(norm_power_3D(:, 3, y_subjective_outcome == 1), 3);
avg_norm_power_unseen = mean(norm_power_3D(:, 3, y_subjective_outcome == 0), 3);


figure('Name', 'dB Suppression Plot');
plot(time_vec_full, avg_norm_power_seen, 'b', 'LineWidth', 2, 'DisplayName', 'Seen (Suppression)');
hold on;
plot(time_vec_full, avg_norm_power_unseen, 'r', 'LineWidth', 2, 'DisplayName', 'Unseen (No Suppression)');

% --- Aesthetics ---
line([0 0], ylim, 'Color', 'k', 'LineStyle', '--');
line(xlim, [0 0], 'Color', 'k', 'LineWidth', 1.5, 'LineStyle', '-'); % Zero line for dB
title(['Alpha Suppression (dB): Seen vs. Unseen at Ch ' num2str(currentROI_name)]);
xlabel('Time relative to stimulus (s)');
ylabel('Power Change (dB)');
legend('show', 'Location', 'SouthEast');
hold off;

%% 5.1 TIME-FREQUENCY (T-MAP) FEATURE EXTRACTION AND HYPOTHESIS TESTING


% --- Variables for the Map Axes ---
n_time_points = size(alpha_power_envelope, 1); % Total time points in the epoch
n_freqs = size(alpha_power_envelope, 2);      % Total frequencies analyzed (5 in your case)

% Define the Pre-Stimulus Time Window (Samples)
pred_start_sample_idx = 1; 
pred_end_sample_idx = pre_samples; 

% Slice the time-frequency data to the prediction window
time_window_samples = pred_end_sample_idx - pred_start_sample_idx + 1;

% --- 2. Initialize Output Matrix ---
% The T-Map will be a 2D matrix: [Time Points x Frequencies]
t_map_matrix = zeros(time_window_samples, n_freqs);
p_map_matrix = zeros(time_window_samples, n_freqs);

disp(['Running T-test across ' num2str(time_window_samples) ' time points and ' num2str(n_freqs) ' frequencies...']);
tic

% --- 3. THE TIME-FREQUENCY LOOP ---
for f_idx = 1:n_freqs % Outer Loop: Iterate through each of the 5 frequencies
    
    for t_idx = 1:time_window_samples % Inner Loop: Iterate through each time point
        
        % --- A. Extract Predictor for the current (t, f) pixel ---
        % Extract the power vector across all trials at this specific time and frequency.
        % The index is alpha_power_envelope(Time, Freq, Trial)
        alpha_power_at_pixel = squeeze(mean(alpha_power_envelope(pred_start_sample_idx + t_idx - 1, f_idx, currentROI, :),3));
        
        % Take log of power (is this standard?)
        %alpha_power_at_pixel = log10(alpha_power_at_pixel);


        % --- B. Split into Groups ---
        alpha_seen_power = alpha_power_at_pixel(y_subjective_outcome ==1); 
        %done in section 3, same for next line
        alpha_missed_power = alpha_power_at_pixel(y_subjective_outcome == 0);
        
        % --- C. Run T-Test (Prediction Test) ---
        if length(alpha_seen_power) > 1 && length(alpha_missed_power) > 1
            [h, p_val, ~, stats] = ttest2(alpha_seen_power, alpha_missed_power, "Tail", "Left");
            
            % Store the T-statistic and P-value in the matrix
            t_map_matrix(t_idx, f_idx) = stats.tstat;
            p_map_matrix(t_idx, f_idx) = p_val;
        else
            t_map_matrix(t_idx, f_idx) = NaN; % Not enough trials
        end
    end % End Time Loop (t_idx)
    
end % End Frequency Loop (f_idx)
toc
disp('Time-Frequency T-map computation finished.');


%% 5.2. PLOT TIME-FREQUENCY T-MAP (Visualization)

figure('Name', 'Predictive T-Map');

% --- 1. Plot the T-statistic over time ---
% You must run the imagesc plot in a previous cell or ensure the setup is run first.
% We will use a consistent plot approach.
time_vec_sec = time_vec_full_epoch(1:pred_end_sample);

freq_vec = linspace(alpha_freq_range(1), alpha_freq_range(2), n_freqs);

% --- A. Plotting the T-Map (The Colored Surface) ---
imagesc(time_vec_sec, freq_vec, t_map_matrix'); 
axis xy; 
colorbar;
clim([-4 4]); 
colormap('jet'); 
hold on; 

% --- B. Adding Significance Contour (Middle Layer) ---
% 1. Create a logical mask for significance (p < 0.05)
% NOTE: We assume the target is p < 0.05, but we use p < 0.5 for demonstration 
% if your true p-values are high due to low N.
significant_mask = (p_map_matrix' < 0.05); 

% 2. Plot the contour lines using the mask
[~, h_contour] = contour(time_vec_sec, freq_vec, significant_mask, [0.5 0.5], 'LineWidth', 3, 'LineColor', 'w', 'LineStyle', ':');

% --- C. Aesthetics and Markers (Top Layer) ---
%line([0 0], ylim, 'Color', 'k', 'LineWidth', 2, 'LineStyle', '--'); 
title(['Time-Frequency T-Map (P < 0.05 Contoured) - Ch: ' num2str(currentROI_name)], 'FontSize', 10);

% --- CRUCIAL FINAL STEPS ---
%set(gca, 'XDir', 'reverse'); % Sets Time direction to flow backward 
xlabel('Time relative to stimulus (s)');
ylabel('Frequency (Hz)');
grid on;
hold off; % Release the figure